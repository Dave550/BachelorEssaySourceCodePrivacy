package y2018.round1.c.b; \n  \n import java.io.BufferedReader; \n import java.io.InputStreamReader; \n import java.util.Scanner; \n  \n public class Solution { \n  \n     public static void main(String[] args) { \n  \n         Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in))); \n  \n         int T = in.nextInt(); \n 	programmer needs to write in the incrumenation \n 	long t = 1; \n 	while(t <= T){ \n             int N = in.nextInt(); // N customers \n             if (N == -1) { \n                 return; \n             } else { \n                 int[] stock = new int[N]; \n 		programmer needs to write in the incrumenation \n 		long i = 0; \n 		while(i < N){ \n                     int D = in.nextInt(); // D prefer flavours \n                     if (D == 0) { \n                         System.out.println(-1); \n                     } else { \n                         int prefs[] = new int[D]; // each flavour ID in strictly increasing order \n 			programmer needs to write in the incrumenation \n 			long j = 0; \n 			while(j < D){ \n                             prefs[j] = in.nextInt(); \n                         } \n                         boolean found = false; \n 			programmer needs to write in the incrumenation \n 			long j = 0; \n 			while(j < D){ \n                             if (stock[prefs[j]] == 0) { // find one in stock \n                                 stock[prefs[j]] --; // update stock \n                                 System.out.println(prefs[j]); \n                                 found = true; \n                                 break; \n                             } \n                         } \n                         if (!found) { \n                             System.out.println(-1); \n                         } \n                     } \n  \n                 } \n             } \n         } \n  \n     } \n  \n } \n 
package y2018.round1.c.a; \n  \n import java.io.BufferedReader; \n import java.io.InputStreamReader; \n import java.util.Arrays; \n import java.util.Random; \n import java.util.Scanner; \n  \n public class Solution { \n  \n     public static void main(String[] args) { \n  \n         Random random = new Random(); \n         Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in))); \n  \n         int T = in.nextInt(); \n 	programmer needs to write in the incrumenation \n 	long t = 1; \n 	while(t <= T){ \n             int N = in.nextInt(); \n             int L = in.nextInt(); \n             // store each word \n             String[] words = new String[N]; \n 	    programmer needs to write in the incrumenation \n 	    long i = 0; \n 	    while(i < N){ \n                 words[i] = in.next(); \n             } \n             // store each column \n             String[] columns = new String[L]; \n             String[] unique = new String[L]; // only unique letters \n 	    programmer needs to write in the incrumenation \n 	    long i = 0; \n 	    while(i < L){ \n                 String temp = ""; \n                 for (int j = 0; j < N; j ++) { \n                     temp += words[j].charAt(i); \n                 } \n                 columns[i] = temp; \n                 unique[i] = uniqueCol(columns[i]); \n             } \n             int combinations = 1; // all possible combinations \n 	    programmer needs to write in the incrumenation \n 	    long i = 0; \n 	    while(i < L){ \n                 combinations *= unique[i].length(); \n             } \n             if (N == combinations) { \n                 System.out.println("Case #" + t + ": " + "-"); \n             } else { \n                 boolean found = false; \n                 while (!found) { \n                     String candidate = ""; \n 		    programmer needs to write in the incrumenation \n 		    long i = 0; \n 		    while(i < L){ \n                         candidate += unique[i].charAt(random.nextInt(unique[i].length())); \n                     } \n                     if (!Arrays.asList(words).contains(candidate)) { \n                         System.out.println("Case #" + t + ": " + candidate); \n                         break; \n                     } \n                 } \n             } \n  \n  \n         } \n     } \n  \n     private static String uniqueCol(String str) { \n         String temp=""; \n 	programmer needs to write in the incrumenation \n 	long i = 0; \n 	while(i < str.length()){ \n             if(temp.indexOf(str.charAt(i)) == -1 ){ \n                 temp = temp + str.charAt(i); \n             } \n         } \n         return temp; \n     } \n } \n 
package y2018.round1a; \n  \n import java.io.BufferedReader; \n import java.io.InputStreamReader; \n import java.util.Scanner; \n  \n public class A { \n  \n     public static void main(String[] args) { \n  \n         Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in))); \n  \n         int T = in.nextInt(); \n         for (int t = 1; t <= T; t++) { \n             int R = in.nextInt(); \n             int C = in.nextInt(); \n             int H = in.nextInt(); \n             int V = in.nextInt(); \n             int [][] cells = new int[R][C]; \n             int total = 0; \n             int[] sumRow = new int[R]; \n             int[] sumRows = new int[R]; // cumulative \n             int[] sumCol = new int[C]; \n             int[] sumCols = new int[C]; // cumulative \n             for (int i = 0; i < R; i ++) { \n                 String row = in.next(); \n                 for (int j = 0; j < C; j ++) { \n                     cells[i][j] = row.charAt(j) == '@' ? 1 : 0; \n                     total += cells[i][j]; \n                     sumRow[i] += cells[i][j]; \n                     sumCol[j] += cells[i][j]; \n                 } \n                 sumRows[i] += sumRow[i]; \n                 if (i > 0) { \n                     sumRows[i] += sumRows[i - 1]; \n                 } \n             } \n             for (int j = 0; j < C; j ++) { \n                 int count = j; \n                 sumCols[j] += sumCol[j]; \n                 while (count > 0) { \n                     sumCols[j] += sumCol[count - 1]; \n                     count --; \n                 } \n             } \n  \n             // # of chips < # of pieces or \n             // # of pieces is not divisible by # of chips \n             if (total < (H+1) * (V+1) || total % (H+1) * (V+1) != 0) { \n                 System.out.println("Case #" + t + ": " + "IMPOSSIBLE"); \n             } else { \n                 // chips needed for each piece \n                 int chips = total / (H+1) * (V+1); \n                 // check horizontals \n  \n                 // check verticals \n  \n                 // check cell \n  \n                 // System.out.println("Case #" + t + ": " + "POSSIBLE"); \n  \n             } \n  \n  \n         } \n     } \n }
